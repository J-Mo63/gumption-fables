*Quality Assurance*

To make sure the product is of an acceptable standard, I must set a series of protocols that it has to adhear to:

- Usability: It is imperative that the user can understand how to use the system corectly. User interface plays an important role in this, as its design can make or break a software solution. To prevent any complications due to usability, I will need to constantly keep in contact with the userbase to guage how well the user inferface works as well as creating a consistent UI design. I can also add a turtorial and how-to to the software to teach the user basic use of the software and this would show the user the functionality of the gameplay. To make sure the user is sufficiently knowlegable about the menu, I am considering adding tooltips that explain the use of each compnent of the menu, combined with a question mark that give a brief explanation of the menu. Finally, in order to test whether the solution properly addresses to criteria of usability, I will need to observe new users adapting to the software and report my findings.

- Maintainability: Another control I can use to test quality is maintainability, where the ease at which changes can be made are tested. The way in which I will ensure that my solution is maintainable is through abstraction. By isolating single jobs to single functions, I can easily interchange them with new code without disrupting the rest of the system. Another way to ensure that the code is maintainable will be to add internal documentation, where I will both fully comment my code, and use meaningful variable names (intrinsic commenting). Internal documentation will hopefully make the task of editing code far easier and less painful. To test maintaiability, I will have to judge how maintainable the code is through my own expreiences in changing the code.

- Efficiency: Efficiency basically is how well the software solution will run on any given hardware environemnt. At this stage, I aim to have it running on at least my own personal laptop, and therefore set my target system specificaions as such:
    - Memory: 1GB
    - Processor: 2.6 GHz
    - Graphics: Intel Iris 1536MB
    - Storage: 200 MB
    - Operating System: OSX 10.10.1
Although I have 100GB of storage to play with, I would hope to keep it below 200MB total. To ensure that I make the project as efficient as it possibly can, I will compress all my resources, such as images and sounds to the smallest size possible (within reason) this will hopefully prevent its size from exceeding 200MB. I can also make code efficient by reusing parts of it as modular functions. The smaller size of files as well as efficient code, will result in less pressure on the memory and processor. The test for this protocol will be whether it runs on my personal laptop, but I can also track its memory and processor usage through the system tools. Assuming that it runs, I will consider the solution to be sufficiently efficient. 

- Accuracy: Accuracy is the measure of how correctly a solution can process and output information. This can be tested any number of ways thoughout my project, by deskchecking my functions output, or by assessing the validity of the data being output by the program. by using abstraction, I can test each function by passing in data, and reciving other data and then I can check the data to ensure its accuracy. I can also test the UI as the location that I click on the screen can be assessed by how close the sprite moves to that location, or alternatively, I can check that the dialogue being displayed by characters is the correct response.